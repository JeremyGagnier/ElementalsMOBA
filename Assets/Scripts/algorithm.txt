FInt timestep = new FInt(0.01666f);
while(true)
{
  bool xIsMin = true;
  FInt minTimestep = timestep;
  foreach(Vector4 pos in mover.hitbox)
  {
    int minY = (mover.position.y + pos.y) / FInt.One;
    FInt minOffY = mover.position.y + pos.y - miny * FInt.One;
  
    FInt xTime = FInt.max;
    FInt yTime = FInt.max;
    
    if (mover.velocity.x < 0)
    {
      int minX = (mover.position.x + pos.x) / FInt.One;
      FInt minOffX = mover.position.x + pos.x - minx * FInt.One;
      xTime = minOffX / -mover.velocity.x;
    }
    else if (mover.velocity.x > 0)
    {
      int maxX = (mover.position.x + pos.x + pos.z - 1) / FInt.One + 1;
      FInt maxOffX = maxX * FInt.One - (mover.position.x + pos.x + pos.z);
      xTime = maxOffx / mover.velocity.x;
    }
    
    if (mover.velocity.y < 0)
    {
      int minY = (mover.position.y + pos.y) / FInt.One;
      FInt minOffY = mover.position.y + pos.y - miny * FInt.One;
      yTime = minOffY / -mover.velocity.y;
    }
    else if (mover.velocity.y > 0)
    {
      int maxY = (mover.position.y + pos.y + pos.w - 1) / FInt.One + 1;
      FInt maxOffY = maxX * FInt.One - (mover.position.y + pos.y + pos.w);
      yTime = maxOffY / mover.velocity.y;
    }
    
    if (minX < minTimestep)
    {
      minTimestep = minX;
      xIsMin = true;
    }
    
    if (minY < minTimestep)
    {
      minTimestep = minY;
      xIsMin = false;
    }
  }
  
  mover.position += mover.velocity * minTimestep;
  timestep -= minTimestep;
  if (timestep == 0)
  {
    break;
  }
  
  bool collision = false;
  foreach(Vector4 pos in mover.hitbox)
  {
    for(int y = ymin; y < ymin + pos.w; ++y)
    {
      if(world.BlockAt(xPos, y) != 0)
      {
        BlockCollide(mover);
        collision = true;
        break;
      }
    }
    if (collision)
    {
      break;
    }
  }
}
